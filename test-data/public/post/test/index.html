<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/css/custom.css">
    <link href="https://fonts.googleapis.com/css2?family=PT+Serif&family=Source+Sans+Pro&display=swap" rel="stylesheet">
    <title>Nutr1t07&#39;s Blog | Nutr1t07&#39;s Blog</title>
  </head>

  <body>
    <div class="container">
      <div class="sidebar">
            <nav>
                <h3 id="logo">Nutr1t07</h3>
                <ul>
                    <li><a href="/">Index</a></li>
                    <li><a href="/friends">Friends</a></li>
                </ul>
            </nav>
            &nbsp;
        </div>
  <div class="content">
  <h3>Aeson Parsing Tips</h3>

  <h5>Array with Objects</h5>
<p>Suppose we have the JSON data:</p>
<pre>
<code>
{
  "media_id": "981538",
  "tags": [ {
      "id": 12227,
      "name": "english"
    }, {
      "id": 58971,
      "name": "japanese"
    } ]
}

</code>

</pre>
<p>We want it to be parsed into the following structure, with the <code>r_tags</code> taking only the name field of tags.</p>
<pre>
<code>
data Result = Result {
    r_id :: Text
  , r_tags :: [Text]
}

</code>

</pre>
<p>The easiest way is to parse via <code>newtype</code> wrapper:</p>
<pre>
<code>
data Result = Result {
    r_media_id :: Text
  , r_tags :: [RTag]
}
instance FromJSON Result where
  parseJSON = withObject "Result" $ \v -> Result
    <$> (v .: "media_id")
    <*> (v .: "tags")

newtype RTag = RTag { tag :: Text }
instance FromJSON RTag where
  parseJSON = withObject "RTag" $ \v ->
    RTag <$> ((v .: "name"))

</code>

</pre>
<p>But we can simplify this by removing the <code>RTag</code> wrapper. But first letâ€™s take a look at some <em>Aeson</em> types:</p>
<pre>
<code>
type Array = Vector Value
type Object = HashMap Text Value
parseJSON :: Value -> Parser a
(.:) :: FromJSON a => Object -> Text -> Parser a

</code>

</pre>
<p>And we can infer that <code>(v .: "tags")</code> parse tags into an Array(so has type Parser Array), inside which elements are parsed by the instance of <code>RTag</code>. Obviously, if we want to parse the tags directly into <em>[Text]</em>, we need to turn the type of <code>(v .: "tags")</code>, <em>Parser Array</em>, into <em>Parser [Text]</em>.</p>
<p>It can be done with a <em>do</em> block, and a little help from <code>toList</code>:</p>
<pre>
<code>
import Data.Foldable (toList)
import Data.Aeson.Types (Parser)

parseJSON = withObject "Result" $ \v -> Result
  <$> (v .: "media_id")
  <*> do
    tagArray <- (v .: "tags") :: Parser Array
    tagObjs <- traverse (parseJSON :: Value -> Parser Object) $ toList tagArray :: Parser [Object]
    traverse (.: "name") tagObjs

</code>

</pre>
<p>Then remove <em>do</em> block:</p>
<pre>
<code>
(v .: "tags") :: Parser Array >>= traverse parseJSON . toList >>= traverse (.: "name")

</code>

</pre>
<h5>Field with different types</h5>
<pre>
<code>
"result": [ {
    "id": 1531017
    "media_id": "148011"
  }, {
    "id": "5137523"
    "media_id": "135611"
  } ]

</code>

</pre>
<p>Look at the id field above, did you find that it can be either a <em>String</em> or <em>Int</em>? It can be parsed using a <code>parseId</code> function.</p>
<pre>
<code>
parseId :: Value -> Parser Text
parseId (Number o) = pure $ (fst . Text.breakOn ".") $ Text.pack $ show o
parseId (String o) = pure o
parseId _ = mzero

</code>

</pre>
<p>With structure:</p>
<pre>
<code>
data Result = Result {
    r_wtf_id :: Text.Text
  , r_media_id :: Text.Text
}
instance FromJSON Result where
  parseJSON = withObject "Result" $ \v -> Result
    <$> ((v .: "id") >>= parseId)
    <*> (v .: "media_id")

</code>

</pre>

  </div>

</body>
</html>
